<!DOCTYPE html>
<head>
<title>SuprPixl by @BenjaminWegener</title>
<!---------------------------------------------------------------------------->
<script src="tf.js"> </script>

<!---------------------------------------------------------------------------->
<script>//https://stackoverflow.com/a/39914235
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
</script> 

<!---------------------------------------------------------------------------->
<script>//global vars
	var imageCanvas, predictedCanvas, ctxImageCanvas, ctxPredictedCanvas;
	function globalVars(){
		MODEL_SAVE_NAME = 'suprpixl0069'; // model name for saving in browser
		LEARNING_RATE = 0.001;
		OPTIMIZER = tf.train.adam(LEARNING_RATE);
		LOSS = 'meanAbsoluteError';
		iterations = 250;
		EPOCHS = 1;
		console.log(tf.version);
		tf.disableDeprecationWarnings();
		tf.enableProdMode();
		//tf.webgl.forceHalfFloat();
	}
</script>

<!---------------------------------------------------------------------------->
<script>//build and load model
async function loadModel(){
	try {
        //throw new Error();
		model = await tf.loadLayersModel('indexeddb://' + MODEL_SAVE_NAME);
		model.compile({optimizer: OPTIMIZER, loss : LOSS});
		console.log('successfully loaded...');
	}catch(err){
		console.log(err+'no model found, building new...');
		
		input = tf.input({shape: [null,null,3]});
        output = input;
        output =  tf.layers.separableConv2d({kernelSize: 3, filters: 48, padding: 'same', strides: 1, activation: 'relu'}).apply(output);
		output =  tf.layers.conv2d({kernelSize: 8, filters: 192, padding: 'same', strides: 4, activation: 'linear'}).apply(output);
		
        function pixelShuffle(inputs, filters){
			outputs = inputs;
            outputs = tf.layers.permute({dims: [3, 1, 2]}).apply(outputs);
            console.log(outputs.shape);
			outputs = tf.layers.reshape({targetShape: [2, 2, outputs.shape[1] / 4, outputs.shape[2], outputs.shape[3]]}).apply(outputs);
	        console.log(outputs.shape);
			outputs = tf.layers.permute({dims: [3, 4, 1, 5, 2]}).apply(outputs);
	        console.log(outputs.shape);
			outputs = tf.layers.reshape({targetShape: [outputs.shape[1], outputs.shape[2] * outputs.shape[3], outputs.shape[4] * outputs.shape[5]]}).apply(outputs);
	        console.log(outputs.shape);
			outputs = tf.layers.permute({dims: [2, 3, 1]}).apply(outputs);
	        console.log(outputs.shape);
			return outputs;
		}

		function channelAttention(inputs, filters){
            outputs = inputs;
			outputs = tf.layers.globalAveragePooling2d({}).apply(outputs);
    		outputs = tf.layers.dense({units: filters / 4, activation: 'relu6'}).apply(outputs);
			outputs = tf.layers.dense({units: filters, activation: 'sigmoid'}).apply(outputs);
			outputs = tf.layers.reshape({targetShape: [1, 1, filters]}).apply(outputs);
			outputs = tf.layers.multiply({}).apply([inputs, outputs]);
			return outputs;
		}		
		function channelAttentionConv(inputs, filters){
            outputs = inputs;
			outputs = tf.layers.globalAveragePooling2d({}).apply(outputs);
    		outputs = tf.layers.reshape({targetShape: [1, 1, filters]}).apply(outputs);
			outputs = tf.layers.conv2d({kernelSize: [1, 5], filters: filters / 4, padding: 'same', strides: 1, activation: 'relu6'}).apply(outputs);
			outputs = tf.layers.conv2d({kernelSize: [1, 5], filters: filters, padding: 'same', strides: 1, activation: 'sigmoid'}).apply(outputs);
			outputs = tf.layers.multiply({}).apply([inputs, outputs]);
			outputs = tf.layers.add({}).apply([inputs, outputs]);
			return outputs;
		}

		output = pixelShuffle(output, 192);
		output = pixelShuffle(output, 48);
		output = pixelShuffle(output, 12);

		upscaled = tf.layers.upSampling2d({size: [2, 2]}).apply(input);
		output = tf.layers.add().apply([upscaled, output])
		model = tf.model({inputs: input, outputs: output});

		await model.save('indexeddb://' + MODEL_SAVE_NAME);
		model.compile({optimizer: OPTIMIZER, loss : LOSS});
	}
}
</script>

<!---------------------------------------------------------------------------->
<script>//get the training image
	function getBatch(rndsize){
	
		smallImageArray = [];
		bigImageArray = [];
		bigTrainingImage = tf.tidy(()=>{
			return tf.div(tf.browser.fromPixels(document.getElementById('bigTrainingImage'), 3), tf.scalar(256));
		});
		smallTrainingImage = tf.tidy(()=>{
			return tf.div(tf.browser.fromPixels(document.getElementById('smallTrainingImage'), 3), tf.scalar(256));
		});
		smallImageArray.push(smallTrainingImage);
		bigImageArray.push(bigTrainingImage);
		return {
			x : tf.stack(smallImageArray),
			y : tf.stack(bigImageArray)
		}
	}
</script>

<!---------------------------------------------------------------------------->
<script>//train loop
async function startTraining(){
	var history;
	console.log(model.summary());
	batch = getBatch(1);
	for (let counter = 0; counter < iterations; counter++){
		startTimerTraining = performance.now();
		history = await model.fit(batch.x, batch.y, {batchSize: 1, epochs: EPOCHS});
		stopTimerTraining = performance.now();
		startTimerPrediction = performance.now();
		predictedImage = tf.tidy(() => {
			return model.predict(batch.x).clipByValue(0, 1);
		});
		stopTimerPrediction = performance.now();
		await tf.browser.toPixels(tf.unstack(predictedImage)[0],predicted);
		await model.save('indexeddb://' + MODEL_SAVE_NAME);
		document.getElementById("log").innerHTML =
			("iteration " + (counter + 1) + "/" + iterations + 
			"<br/>loss(mae): " + history.history.loss[0].toFixed(5) + 
			"<br/>training: " + (stopTimerTraining - startTimerTraining).toFixed(0) + "ms" +
			"<br/>prediction : " + (stopTimerPrediction - startTimerPrediction).toFixed(0) + "ms");
	}
}
</script>
<!---------------------------------------------------------------------------->
</head> <!-- starting function -->
<body>
	<div id="log"></div>
	<img id="smallTrainingImage" src="test_128p.jpg"/> (low resolution)<br/>
	<img id="bigTrainingImage" src="test_256p.jpg"/> (ground truth)<br/>
	<canvas id="predicted"></canvas> (predicted output)<br/>
	<img id="browserScaled" src="test_128p.jpg" width="256px" height="256px"/> (browser upscaled)<br/>
</body>
<script>
window.onload = async function(){
	setTimeout(async function(){
		await globalVars();
		await loadModel();
		await startTraining();
	}, 1000);
}
</script>
</html>